<?php
namespace Maksv\MachineLearning;

class Assistant
{
    public function __construct(string $host = 'http://127.0.0.1:8000'){}

    public static $nBars = 30;
    public static $mBars = 100;
    public static $intervalMinutes = 15;
    public static $intervalMs = 15 * 60 * 1000; // 15 минут в миллисекундах

    public static function collectAndStoreTrainData(array $finalResults, string $market, $bybitApiOb, $binanceApiOb): void
    {
        $trainDataFile = $_SERVER["DOCUMENT_ROOT"] . '/ml/data/train_data.json';
        // 1) Пробуем загрузить уже существующие данные из JSON-файла
        $allData = [];
        if (file_exists($trainDataFile)) {
            $json = file_get_contents($trainDataFile);
            if ($json !== false) {
                $decoded = json_decode($json, true);
                if (is_array($decoded)) {
                    $allData = $decoded;
                }
            }
        }
        $allCount = $procCount = $continueCount = 0;

        // 2) Обрабатываем каждый сигнал из finalResults
        foreach ($finalResults as $res) {
            $allCount++;
            // 2.1) Парсим дату сигнала
            $dt = \DateTime::createFromFormat(
                'd.m.Y H:i:s',
                $res['date'],
                new \DateTimeZone('Europe/Amsterdam')
            );
            if ($dt === false) {
                // пропускаем некорректные даты
                continue;
            }
            $signalTimestampMs = $dt->getTimestamp() * 1000;
            $key = $res['symbolName'] . '_' . $signalTimestampMs;

            // 2.2) Если уже есть запись с таким ключом — пропускаем
            if (isset($allData[$key])) {
                $continueCount++;
                continue;
            }
            $procCount++;

            // 2.3) Считаем интервалы (30 баров до сигнала и 100 баров после)
            $startTimeMs = $signalTimestampMs - (Assistant::$nBars * Assistant::$intervalMs);
            $endTimeMs   = $signalTimestampMs + (Assistant::$mBars * Assistant::$intervalMs);
            $symbolName  = $res['symbolName'];
            $useCache    = true;
            $cacheTime   = 86400;
            $limit       = Assistant::$nBars + Assistant::$mBars + 10; // 30 + 100 + 10 = 140

            // 2.4) Получаем “сырые” бары с биржи
            $rawBars = [];
            if ($market === 'bybit') {
                try {
                    $resp = $bybitApiOb->klineTimeV5(
                        "linear",
                        $symbolName,
                        $startTimeMs,
                        $endTimeMs,
                        '15m',
                        $limit,
                        $useCache,
                        $cacheTime
                    );
                } catch (\Exception $e) {
                    // при ошибке API — пропускаем
                    continue;
                }
                if (empty($resp['result']['list']) || !is_array($resp['result']['list'])) {
                    continue;
                }
                $rawBars = $resp['result']['list'];
                usort($rawBars, fn($a, $b) => $a[0] <=> $b[0]);

            } elseif ($market === 'binance') {
                try {
                    $bars = $binanceApiOb->kline(
                        $symbolName,
                        '15m',
                        $limit,
                        $startTimeMs,
                        $endTimeMs,
                        $useCache,
                        $cacheTime
                    );
                } catch (\Exception $e) {
                    continue;
                }
                if (empty($bars) || !is_array($bars)) {
                    continue;
                }
                $rawBars = $bars;
                usort($rawBars, fn($a, $b) => $a[0] <=> $b[0]);
            } else {
                continue;
            }

            // 2.5) Преобразуем бары в ассоц. формат ['t','o','h','l','c','v']
            $candlesAll = array_map(function($bar) {
                return [
                    't' => floatval($bar[0]),
                    'o' => floatval($bar[1]),
                    'h' => floatval($bar[2]),
                    'l' => floatval($bar[3]),
                    'c' => floatval($bar[4]),
                    'v' => floatval($bar[5]),
                ];
            }, $rawBars);

            // 2.6) Разбиваем на “до” и “после” по метке времени сигнала
            $historicalAll = [];
            $futureAll     = [];
            foreach ($candlesAll as $bar) {
                if ($bar['t'] < $signalTimestampMs) {
                    $historicalAll[] = [
                        'o' => $bar['o'],
                        'h' => $bar['h'],
                        'l' => $bar['l'],
                        'c' => $bar['c'],
                        'v' => $bar['v'],
                    ];
                } else {
                    $futureAll[] = [
                        'h' => $bar['h'],
                        'l' => $bar['l'],
                    ];
                }
            }

            // 2.7) Проверяем достаточное количество баров
            if (count($historicalAll) < Assistant::$nBars || count($futureAll) < Assistant::$mBars) {
                continue;
            }

            // 2.8) Вырезаем ровно нужное число баров
            $historical = array_slice($historicalAll, -Assistant::$nBars);
            $future     = array_slice($futureAll, 0, Assistant::$mBars);
            if (count($historical) !== Assistant::$nBars || count($future) !== Assistant::$mBars) {
                continue;
            }

            // 2.9) Собираем структуру, добавляем поле 'date'
            $entryPrice = floatval($res['allInfo']['entryTarget']);
            if ($entryPrice == 0)
                $entryPrice =  floatval($res['allInfo']['actualClosePrice']);

            /* $tpsRaw     = (array)$res['allInfo']['TP'];
             $tps        = array_map(fn($x) => floatval($x), $tpsRaw);*/

            $tpsRaw     = (array)$res['allInfo']['TP'];
            $tps        = array_map(fn($x) => floatval($x), $tpsRaw);
            if (count($tps) > 3)
                $tps = array_slice($tps, 0, 3);

            $slPrice    = floatval($res['allInfo']['SL']);

            $trainSignal = [
                'candles'   => $historical,                  // exactly Assistant::$nBars bars ['o','h','l','c','v']
                'entry'     => $entryPrice,
                'tps'       => $tps,                          // array of take-profit values
                'sl'        => $slPrice,
                'future'    => $future,                       // exactly Assistant::$mBars bars ['h','l']
                'direction' => $res['direction'],             // "long" or "short"
                'date'      => $dt->format('d.m.Y H:i:s'),
            ];

            // 2.10) Сохраняем в общий массив под ключом "<symbolName>_<timestamp>"
            $allData[$key] = $trainSignal;
        }

        // 3) После обработки всех finalResults — сохраняем обновлённый JSON (с LOCK_EX)
        $jsonToSave = json_encode($allData, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
        if ($jsonToSave !== false) {
            file_put_contents($trainDataFile, $jsonToSave, LOCK_EX);
        }

        echo '<div class="ai-analyze-wrapper">';
        echo "allCount: " . $allCount . "\n";
        echo "continueCount: " . $continueCount . "\n";
        echo "procCount: " . $procCount . "\n";
        echo "</div>";
    }

    public static function trainRes(array $ignored = [], string $ignored2 = '', $ignored3 = null, $ignored4 = null): array
    {
        $trainDataFile = $_SERVER["DOCUMENT_ROOT"] . '/ml/data/train_data.json';

        $trainBatch = [];
        $resp       = null;

        // 1) Читаем JSON-файл с накопленными данными
        if (!file_exists($trainDataFile)) {
            echo '<div class="ai-analyze-wrapper">Файл данных для обучения не найден.</div>';
            return ['trainBatch' => [], 'resp' => null];
        }

        $json = file_get_contents($trainDataFile);
        if ($json === false) {
            echo '<div class="ai-analyze-wrapper">Не удалось прочитать файл данных для обучения.</div>';
            return ['trainBatch' => [], 'resp' => null];
        }

        $decoded = json_decode($json, true);
        if (!is_array($decoded) || empty($decoded)) {
            echo '<div class="ai-analyze-wrapper">Нет данных для обучения (JSON пуст или некорректен).</div>';
            return ['trainBatch' => [], 'resp' => null];
        }

        // 2) Формируем trainBatch как просто список значений (игнорируем ключи "<symbol>_<timestamp>")
        $trainCountAll = 0;
        foreach ($decoded as $key => $item) {
            $trainCountAll++;
            // Каждый $item уже содержит нужную структуру:
            // [ 'candles', 'entry', 'tps', 'sl', 'future', 'direction', 'date' ]
            $trainBatch[] = $item;
        }

        // 3) Если есть что тренировать — шлём весь массив в ML
        if (!empty($trainBatch)) {
            try {
                $ml   = new \Maksv\MachineLearning\Request('http://127.0.0.1:8000');
                $resp = $ml->train($trainBatch);
                echo '<div class="ai-analyze-wrapper">ML training response:' . "\n";
                print_r($resp);
                echo "</div>";
            } catch (\Exception $e) {
                echo '<div class="ai-analyze-wrapper">';
                echo "Ошибка при тренировке ML: " . $e->getMessage() . "\n";
                echo "</div>";
            }
        } else {
            echo '<div class="ai-analyze-wrapper">';
            echo "Нет данных для обучения в файле.\n";
            echo "</div>";
        }

        return ['trainBatch' => $trainBatch, 'resp' => $resp, 'trainCountAll' => $trainCountAll];
    }

    public static function predictRes(array $finalResults, string $market, $bybitApiOb, $binanceApiOb)
    {
        foreach ($finalResults as $res) {
            $symbolName = $res['symbolName'];
            $rawDate    = $res['date']; // "d.m.Y H:i:s"
            $dt = \DateTime::createFromFormat(
                'd.m.Y H:i:s',
                $rawDate,
                new \DateTimeZone('Europe/Amsterdam')
            );
            if ($dt === false) {
                echo '<pre>';
                echo "[{$symbolName}] Неверный формат даты: {$rawDate}\n";
                echo '</pre>';
                continue;
            }
            $signalTimestampMs = $dt->getTimestamp() * 1000;

            // Берём ровно Assistant::$nBars баров до сигнала
            $endTimeMs   = $signalTimestampMs;
            $startTimeMs = $signalTimestampMs - (Assistant::$nBars * Assistant::$intervalMs);

            $candles = [];
            if ($market === 'bybit') {
                $useCache   = true;
                $cacheTime  = 86400;
                $limit      = Assistant::$nBars; // ровно 30

                $resp = $bybitApiOb->klineTimeV5(
                    "linear",
                    $symbolName,
                    $startTimeMs,
                    $endTimeMs,
                    '15m',
                    $limit,
                    $useCache,
                    $cacheTime
                );
                if (
                    empty($resp['result']) ||
                    empty($resp['result']['list']) ||
                    !is_array($resp['result']['list'])
                ) {
                    echo '<pre>';
                    echo "[{$symbolName} @ {$dt->format('d.m H:i')}] Нет данных от Bybit\n";
                    echo '</pre>';
                    continue;
                }
                $bars = $resp['result']['list'];
                usort($bars, fn($a, $b) => $a[0] <=> $b[0]);

                foreach ($bars as $b) {
                    $candles[] = [
                        'o' => floatval($b[1]),
                        'h' => floatval($b[2]),
                        'l' => floatval($b[3]),
                        'c' => floatval($b[4]),
                        'v' => floatval($b[5]),
                    ];
                }
            }
            elseif ($market === 'binance') {
                $useCache   = true;
                $cacheTime  = 604800;
                $limit      = Assistant::$nBars; // 30

                $bars = $binanceApiOb->kline(
                    $symbolName,
                    '15m',
                    $limit,
                    $startTimeMs,
                    $endTimeMs,
                    $useCache,
                    $cacheTime
                );
                if (empty($bars) || !is_array($bars)) {
                    echo '<pre>';
                    echo "[{$symbolName} @ {$dt->format('d.m H:i')}] Нет данных от Bin\n";
                    echo '</pre>';
                    continue;
                }
                usort($bars, fn($a, $b) => $a[0] <=> $b[0]);

                foreach ($bars as $b) {
                    $candles[] = [
                        'o' => floatval($b[1]),
                        'h' => floatval($b[2]),
                        'l' => floatval($b[3]),
                        'c' => floatval($b[4]),
                        'v' => floatval($b[5]),
                    ];
                }
            }
            else {
                echo '<pre>';
                echo "[{$symbolName}] Маркет '{$market}' не поддерживается\n";
                echo '</pre>';
                continue;
            }

            // Проверяем, что ровно 30 баров
            if (count($candles) < Assistant::$nBars) {
                echo '<pre>';
                echo "[{$symbolName} @ {$dt->format('d.m H:i')}] Получено " . count($candles) . " баров, нужно 30\n";
                echo '</pre>';
                continue;
            }
            if (count($candles) > Assistant::$nBars) {
                $candles = array_slice($candles, -Assistant::$nBars);
            }

            // TP/SL и direction
            $entryPrice = floatval($res['allInfo']['entryTarget']);
            if ($entryPrice == 0)
                $entryPrice =  floatval($res['allInfo']['actualClosePrice']);

            $tpsRaw     = (array)$res['allInfo']['TP'];
            $tps        = array_map(fn($x) => floatval($x), $tpsRaw);
            if (count($tps) > 3)
                $tps = array_slice($tps, 0, 3);

            $slPrice    = floatval($res['allInfo']['SL']);

            $payload = [
                'candles'   => $candles,
                'entry'     => $entryPrice,
                'tps'       => $tps,
                'sl'        => $slPrice,
                'direction' => $res['direction'],
            ];

            //echo '<pre>';
            //echo "=== Predict для {$symbolName} @ {$dt->format('d.m H:i')} ===\n";

            try {
                $ml = new \Maksv\MachineLearning\Request('http://127.0.0.1:8000');
                $response = $ml->predict($payload);
                $response['symbolName'] = $symbolName;
                $response['date'] = $dt->format('d.m.Y H:i:s'); // "28.04.2025 02:11:57"
                $resAr[$symbolName . '_' .  $dt->getTimestamp()] = $response;
                //echo "Ответ ML (вероятности SL/TP):\n";
                //print_r($response);
            } catch (\Exception $e) {
                echo '<pre>';
                echo "Ошибка ML: " . $e->getMessage() . "\n";
                echo '</pre>';
            }

            //echo "\n";
            //echo '</pre>';
        }
        return $resAr;
    }

}
